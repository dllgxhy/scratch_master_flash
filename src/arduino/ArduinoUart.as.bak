/*
 * Scratch Project Editor and Player
 * Copyright (C) 2014 Massachusetts Institute of Technology
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

// ArduinoUart.as
// John Maloney, September 2009
//
// 该部分的作用是对串口进行处理

/*******************************************
串口设置初始化函数应用举例
public var arduino:ArduinoConnector;

public function initApp():void
{
        arduino = new ArduinoConnector();
        arduino.connect("COM10",9600);
}

protected function closeApp(event:Event):void
{
        arduino.dispose();                              
}



串口写入数据的api函数
public function writeByte(byte:uint):Boolean
public function writeString(stringToSend:String):Boolean
public function writeBytes(bytesToSend:ByteArray?):Boolean

串口读取数据的api函数
public function readBytesAsArray():Array
public function readBytesAsString():String
public function readBytesAsByteArray():ByteArray?
public function readByte():uint
*******************************************/

package arduino{

import com.quetwo.Arduino.ArduinoConnector;
import com.quetwo.Arduino.ArduinoConnectorEvent;

import flash.display.Sprite;

public class ArduinoUart extends Sprite{
	
	private var arduinoUartBaud:Number = 115200;
	private var arduinoComID:String = '0';
	
	public var arduinoUart:ArduinoConnector = new ArduinoConnector();	//串口类
	public var comWorking:Boolean = false;		//COM口是否开启
	public var comWorkID:String = '0';				//当前选中打开的COM口
	public var comDataBuffer:Array = new Array();//串口接收数据缓存
	public var comDataBufferOld:Array = new Array();//串口接收数据缓存未处理数据
	public var comRevDataAvailable:Boolean = false;//串口数据接收完整性判断标识
	
	public var readUartDataType:String = '0';   //读取到的数据类型
	public var readUartOperaCode:Array;         //读取到的数据内容
	private var uartCommunicationPackageHead:Array = [0xfe, 0xfd];
	private var uartCommunicationPackageTail:Array = [0xfe, 0xfb];
	private var uartReadDataTypeID:int = 0x00;
	
	private var communicationBetweenScratchArduinoStatus:Boolean = false;
	
	

	public function ArduinoUart(baud:Number):void
	{
		this.arduinoUartBaud = baud;
		
	}
//通讯协议定义
	private var comAvailBetweenScratchArduino:String = "test uart";  //通讯状态指令
	
/*串口连接*/	
	public function uartConnect(comID:String):Boolean 
	{
		arduinoUart.connect(comID,arduinoUartBaud);
		return false;
	}
/*串口断开*/
	public function uartDisconnet():void
	{	
		arduinoUart.dispose();
	}
	
/*
串口状态查询
*/
	public function uartStatusBetweenScratchArduino():Boolean
	{
		var comArray:Array = new Array();
		comArray = checkUartAvail();
		for(var i:int = 0x01;i <= 16;i++)
		{
			if(comArray[i] == i)   //如果当前串口为有效串口
			{
				arduinoUart.writeString(comAvailBetweenScratchArduino);					//则向该串口发送数据
			}
		}
		return false;
	}

/***************************************************
scratch 通过UART 向Arduino写入数据
***************************************************/
	public function scratchWriteData2Arduino(scratchWrite2ArduinoBuffer:Array)
	{
		
		arduinoUart.writeByte(scratchWrite2ArduinoBuffer);
	}

/*	
串口检测，输出扫描到的所有有效串口号
有效串口号可能有几个，比如在电脑上插入了串口调试助手等，所以还需要检测是否通讯成功。
*/
	public function checkUartAvail():Array
	{
		var comAvailArray:ByteArray = new ByteArray();
		
		comAvailArray[0] = uartCommunicationPackageHead[0];
		comAvailArray[1] = uartCommunicationPackageHead[1];
		comAvailArray[2] = 0xfe;
		comAvailArray[3] = 0xfe;
		comAvailArray[4] = uartCommunicationPackageTail[0];
		comAvailArray[5] = uartCommunicationPackageTail[1];
		
		for(var i:int =1;i<=16;i++)
		{		
			arduinoUart.close();//重新关闭_wh
			if(arduinoUart.connect("COM"+i))//判断是否能打开成功_wh
			{
				if (scratchWriteData2Arduino(comAvailArray))
				{
					comAvailArray.push("COM"+i);
				}
			}	
		}
		arduinoUart.close();//重新关闭_wh
		return comAvailArray;
	}	


/*********************************************************************
串口数据接收事件处理
ArduinoConnector.ane读取串口数据的api接口
public function readBytesAsArray():Array
public function readBytesAsString():String
public function readBytesAsByteArray():ByteArray?
public function readByte():uint
*********************************************************************/
public function fncArduinoData(aEvt: ArduinoConnectorEvent):void
{
	try
	{
		comDataBufferOld = comDataBufferOld.concat(arduinoUart.readBytesAsArray());//将接收到的数据放在comDataArrayOld数组中_wh
	}
	catch(Error)
	{
//			Scratch.app.log(LogLevel.WARNING, 'Failed server request', {event: event, url: url, data: data});
		return;
	}
	
	while(1)
	{
		comDataBuffer.length =0;
		//将接收到的ASCII码字符型转成数值型_wh
		for(var i:int = 0; i < comDataBufferOld.length; i++)
			comDataBuffer[i] = comDataBufferOld[i].charCodeAt(0);
		//接收通信协议：0xee 0x66; 0xXX（类型）; 0xXX（编号）; 0xXX...（值）_wh
		if((comDataBuffer[0] == 0xee) || (comDataBufferOld.length == 0))//comDataArray中为ASCII码字符型，判断不等？_wh
		{
			if(comDataBuffer[1] == 0x66)
			{
				//根据类别进行初步数据有效性判断_wh
				switch(comDataBuffer[2])
				{
//					case CFunPrims.ID_ReadDigital:if(comDataBuffer.length >= 8) comRevFlag = true;break;//数据接收完整判断_wh
//					case CFunPrims.ID_ReadAnalog:if(comDataBuffer.length >= 8) comRevFlag = true;break;//数据接收完整判断_wh
					default:break;
				}
				break;
			}
			//数据左移一位_wh
			if(comDataBuffer.length >= 2)
				comDataBufferOld.shift();//数组整体前移一位_wh
				//数据未接收全_wh
			else
				break;
		}
		else
		{
			comDataBufferOld.shift();//数组整体前移一位_wh
		}
	}
}
/**************************************************
将串口接收到的数据按照协议进行解包
**************************************************/
	private function paraUartData():void
	{
		
	}
	
	
}}
